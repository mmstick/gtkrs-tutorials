<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inserting and Removing Tasks - Event-Driven GTK by Example — 2021 Edition</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1x00-intro.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1x01-about-gtk.html"><strong aria-hidden="true">1.1.</strong> About GTK</a></li><li class="chapter-item expanded "><a href="1x02-getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="1x03-glib-runtime.html"><strong aria-hidden="true">1.3.</strong> Using GLib as an Async Runtime</a></li><li class="chapter-item expanded "><a href="1x04-event-driven.html"><strong aria-hidden="true">1.4.</strong> Event-Driven Approach</a></li><li class="chapter-item expanded "><a href="1x05-window.html"><strong aria-hidden="true">1.5.</strong> Creating a Window with a Button</a></li><li class="chapter-item expanded "><a href="1x06-gtk-widgets.html"><strong aria-hidden="true">1.6.</strong> GTK Widget Reference</a></li></ol></li><li class="chapter-item expanded "><a href="2x00-intro.html"><strong aria-hidden="true">2.</strong> ToDo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2x01-gtk-application.html"><strong aria-hidden="true">2.1.</strong> Using gtk::Application</a></li><li class="chapter-item expanded "><a href="2x02-events.html"><strong aria-hidden="true">2.2.</strong> Modeling Our Events</a></li><li class="chapter-item expanded "><a href="2x03-background-events.html"><strong aria-hidden="true">2.3.</strong> Loading and Savings in the Background</a></li><li class="chapter-item expanded "><a href="2x04-task-widget.html"><strong aria-hidden="true">2.4.</strong> Creating the Task Widget Struct</a></li><li class="chapter-item expanded "><a href="2x05-app.html"><strong aria-hidden="true">2.5.</strong> Creating the Base App</a></li><li class="chapter-item expanded "><a href="2x06-tasks.html" class="active"><strong aria-hidden="true">2.6.</strong> Inserting and Removing Tasks</a></li><li class="chapter-item expanded "><a href="2x07-save.html"><strong aria-hidden="true">2.7.</strong> Signaling When to Save</a></li><li class="chapter-item expanded "><a href="2x08-load.html"><strong aria-hidden="true">2.8.</strong> Loading Tasks From a File</a></li><li class="chapter-item expanded "><a href="2x09-check-buttons.html"><strong aria-hidden="true">2.9.</strong> Marking &amp; Removing Done Tasks with CheckButtons</a></li><li class="chapter-item expanded "><a href="2x10-multi-list.html"><strong aria-hidden="true">2.10.</strong> Managing Multiple ToDo Lists</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Event-Driven GTK by Example — 2021 Edition</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inserting-and-removing-tasks"><a class="header" href="#inserting-and-removing-tasks">Inserting and Removing Tasks</a></h1>
<h2 id="apprs"><a class="header" href="#apprs">app.rs</a></h2>
<h3 id="inserting-a-row"><a class="header" href="#inserting-a-row">Inserting a Row</a></h3>
<p>Back to our <code>App</code> struct, we're going to work on the ability to insert a row by the row indice.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_row(&amp;mut self, row: i32) -&gt; TaskEntity {

}
<span class="boring">}
</span></code></pre></pre>
<p>When inserting a row, we will want to increment the row value of each task is below the row being added. We can achieve that by iterating our SlotMap of tasks by value, mutably. task that has a row that is greater or equal to the row being inserted will be incremented by 1.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increment the row value of each Task is below the new row
for task in self.tasks.values_mut() {
    if task.row &gt;= row {
        task.row += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we instruct our <code>gtk::Grid</code> to insert this new row, pushing down all rows beneath it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.container.insert_row(row);
<span class="boring">}
</span></code></pre></pre>
<p>Next we'll create our task widgets, and assign them to the grid. The <code>.attach()</code> method takes the widget to assign, followed by the column, row, width, and height parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task = Task::new(row);

self.container.attach(&amp;task.entry, 0, row, 1, 1);
self.container.attach(&amp;task.insert, 1, row, 1, 1);
self.container.attach(&amp;task.remove, 2, row, 1, 1);
<span class="boring">}
</span></code></pre></pre>
<p>We should also ensure that the newly-added <code>gtk::Entry</code> will grab the focus of our keyboard</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>task.entry.grab_focus();
<span class="boring">}
</span></code></pre></pre>
<p>Now we can assign this newly-created <code>Task</code> to our SlotMap. This will return a key, which we will use as identifiers to the signals we're now going to connect.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = self.tasks.insert(task);
self.tasks[entity].connect(self.tx.clone(), entity);
return entity;
<span class="boring">}
</span></code></pre></pre>
<p>Your method should now look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_row(&amp;mut self, row: i32) -&gt; TaskEntity {
    // Increment the row value of each Task is below the new row
    for task in self.tasks.values_mut() {
        if task.row &gt;= row {
            task.row += 1;
        }
    }

    self.container.insert_row(row);
    let task = Task::new(row);

    self.container.attach(&amp;task.entry, 0, row, 1, 1);
    self.container.attach(&amp;task.insert, 1, row, 1, 1);
    self.container.attach(&amp;task.remove, 2, row, 1, 1);

    task.entry.grab_focus();

    let entity = self.tasks.insert(task);
    self.tasks[entity].connect(self.tx.clone(), entity);
    return entity;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="widgetsrs"><a class="header" href="#widgetsrs">widgets.rs</a></h2>
<p>It is at this point where we are going to start connecting the signals to our task widgets. Add the following method to your <code>Task</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn connect(&amp;mut self, tx: Sender&lt;Event&gt;, entity: TaskEntity) {

}

<span class="boring">}
</span></code></pre></pre>
<p>First we will have the entry send <code>Event::Modified</code> whenever it has changed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.entry.connect_changed(clone!(@strong tx =&gt; move |_| {
    let tx = tx.clone();
    spawn(async move {
        let _ = tx.send(Event::Modified).await;
    });
}));
<span class="boring">}
</span></code></pre></pre>
<p>Then we will program insert button to send <code>Event::Insert(entity)</code> when it has been clicked. Although we will only send this signal if the entry for this task is empty. Note that we are taking the entry widget by weak reference. This will prevent a potential cyclic reference when two widgets happen to depend on each other in their signals. The <code>clone!</code> macro will automatically handle creating the weak reference, and upgrading that reference in our signal.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.insert
    .connect_clicked(clone!(@strong tx, @weak self.entry as entry =&gt; move |_| {
        if entry.get_text_length() == 0 {
            return;
        }

        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::Insert(entity)).await;
        });
    }));
<span class="boring">}
</span></code></pre></pre>
<p>Then the remove button:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.remove.connect_clicked(clone!(@strong tx =&gt; move |_| {
    let tx = tx.clone();
    spawn(async move {
        let _ = tx.send(Event::Remove(entity)).await;
    });
}));
<span class="boring">}
</span></code></pre></pre>
<p>And to respond to when the user presses the Enter key, which should be treated as equivalent to clicking the insert button:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    self.entry
        .connect_activate(clone!(@weak self.entry as entry =&gt; move |_| {
            if entry.get_text_length() == 0 {
                return;
            }

            let tx = tx.clone();
            spawn(async move {
                let _ = tx.send(Event::Insert(entity)).await;
            });
        }));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="apprs-1"><a class="header" href="#apprs-1">app.rs</a></h2>
<p>Moving back to our app module, we'll add another method for inserting a row. Because our application is going to insert new rows from received events via the <code>TaskEntity</code> that was received in the <code>Insert(TaskEntity)</code> event, we need to add the method that our application is going to call. After fetching the task from the SlotMap, we can use the conveniently-stored <code>row</code> value to determine where we're going to insert a new row.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insert(&amp;mut self, entity: TaskEntity) {
    let mut insert_at = 0;

    if let Some(task) = self.tasks.get(entity) {
        insert_at = task.row + 1;
    }

    self.insert_row(insert_at);
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we get to removing tasks. When we receive that <code>Remove(TaskEntity)</code> event, we're going to call <code>app.remove(entity)</code>. We'll ignore any requests to delete the last task from the list, since that would render our application unusable. If we're allowed to remove a task, we'll remove the task from the SlotMap, and call <code>grid.remove_row(&amp;widget)</code> on our <code>container</code> to remove all the widgets from that task's row from the container. The widgets will be automatically destroyed after returning from this function, because the last remaining strong references to them have been wiped out.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn remove(&amp;mut self, entity: TaskEntity) {
    if self.tasks.len() == 1 {
        return;
    }
    self.remove_(entity);
}

fn remove_(&amp;mut self, entity: TaskEntity) {
    if let Some(removed) = self.tasks.remove(entity) {
        self.container.remove_row(removed.row);

        // Decrement the row value of the tasks that were below the removed row
        for task in self.tasks.values_mut() {
            if task.row &gt; removed.row {
                task.row -= 1;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And of course, similar to having to increment the row values on insert, we'll do the reverse on removal of a widget.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="2x05-app.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="2x07-save.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="2x05-app.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="2x07-save.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
