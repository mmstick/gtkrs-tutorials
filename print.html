<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Event-Driven GTK by Example — 2021 Edition</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1x00-intro.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1x01-about-gtk.html"><strong aria-hidden="true">1.1.</strong> About GTK</a></li><li class="chapter-item expanded "><a href="1x02-getting-started.html"><strong aria-hidden="true">1.2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="1x03-glib-runtime.html"><strong aria-hidden="true">1.3.</strong> Using GLib as an Async Runtime</a></li><li class="chapter-item expanded "><a href="1x04-event-driven.html"><strong aria-hidden="true">1.4.</strong> Event-Driven Approach</a></li><li class="chapter-item expanded "><a href="1x05-window.html"><strong aria-hidden="true">1.5.</strong> Creating a Window with a Button</a></li><li class="chapter-item expanded "><a href="1x06-gtk-widgets.html"><strong aria-hidden="true">1.6.</strong> GTK Widget Reference</a></li></ol></li><li class="chapter-item expanded "><a href="2x00-intro.html"><strong aria-hidden="true">2.</strong> ToDo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2x01-gtk-application.html"><strong aria-hidden="true">2.1.</strong> Using gtk::Application</a></li><li class="chapter-item expanded "><a href="2x02-events.html"><strong aria-hidden="true">2.2.</strong> Modeling Our Events</a></li><li class="chapter-item expanded "><a href="2x03-background-events.html"><strong aria-hidden="true">2.3.</strong> Loading and Savings in the Background</a></li><li class="chapter-item expanded "><a href="2x04-task-widget.html"><strong aria-hidden="true">2.4.</strong> Creating the Task Widget Struct</a></li><li class="chapter-item expanded "><a href="2x05-app.html"><strong aria-hidden="true">2.5.</strong> Creating the Base App</a></li><li class="chapter-item expanded "><a href="2x06-tasks.html"><strong aria-hidden="true">2.6.</strong> Inserting and Removing Tasks</a></li><li class="chapter-item expanded "><a href="2x07-save.html"><strong aria-hidden="true">2.7.</strong> Signaling When to Save</a></li><li class="chapter-item expanded "><a href="2x08-load.html"><strong aria-hidden="true">2.8.</strong> Loading Tasks From a File</a></li><li class="chapter-item expanded "><a href="2x09-check-buttons.html"><strong aria-hidden="true">2.9.</strong> Marking &amp; Removing Done Tasks with CheckButtons</a></li><li class="chapter-item expanded "><a href="2x10-multi-list.html"><strong aria-hidden="true">2.10.</strong> Managing Multiple ToDo Lists</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Event-Driven GTK by Example — 2021 Edition</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<blockquote>
<p>This tutorial series is currently a work in progress. <a href="https://github.com/mmstick/gtkrs-tutorials">GitHub</a></p>
</blockquote>
<p>The purpose of this tutorial is to demonstrate GTK application development in Rust from an event-drive perspective. After gaining a lot of experience, I have come to the conclusion that this is the best way to develop GTK applications, and through this tutorial I will share what I consider to be best practices.</p>
<p>Besides the first chapter, each chapter will contain a useful application that you will develop alongside the tutorial. Through this, you will gain some insight into how these applications are developed, and gain experience with a variety of aspects that GTK and Rust have to offer to an application developer.</p>
<p>You will learn the following:</p>
<ul>
<li>First and foremost, GLib and GTK</li>
<li>How to navigate the GTK-rs API documentation</li>
<li>Using GLib's global and thread-local async executors</li>
<li>Creating and configuring widgets with cascade macro</li>
<li>APP IDs and preventing applications from launching multiple instances</li>
<li>Adding an event handler in a GTK application</li>
<li>Utilizing an entity-component approach to widget management</li>
<li>Adhering to XDG standards</li>
<li>Embedding resources into a GTK applications</li>
<li>Translating applications with Fluent</li>
<li>Packaging for Debian platforms</li>
<li>GNOME Human Interface Guidelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="about-gtk"><a class="header" href="#about-gtk">About GTK</a></h1>
<blockquote>
<p><strong>WARNING</strong>: This tutorial assumes familiarity with Rust.</p>
</blockquote>
<p>Before we begin, it is important to know a few things about GTK itself. The architecture that GTK is built upon strongly influences the way that we will interact with it. Yet I won't dive too deeply into the details, because we only need cover what's most important for us as a consumer of the API in Rust.</p>
<h2 id="gtk-is-built-around-glib"><a class="header" href="#gtk-is-built-around-glib">GTK is built around GLib</a></h2>
<p>GTK is a GUI toolkit built strongly around GLib and it's GLib Object System — which we'll simply call GObject. GLib is essentially a high level cross-platform standard library for C. The GObject portion of GLib enables programming with an object-oriented paradigm.</p>
<p>GTK uses GLib both for it's object system and asynchronous runtime. Every widget type is a GObject class, and most widget classes inherit multiple layers of GTK widget classes. Widgets schedule tasks for concurrent execution on the default async executor (<code>gtk::MainContext::default()</code>), and register signals that react to various property and state changes.</p>
<p>Luckily for us, the behaviors of every class implemented in GTK can be conveniently represented as a trait in Rust. Even better, GTK fully supports a feature known as &quot;GObject Introspection&quot;, which is a convenient way of automatically generating quality bindings in other programming languages. This allowed GTK to have first class bindings in a short amount of time.</p>
<h2 id="initialized-widgets-are-objects"><a class="header" href="#initialized-widgets-are-objects">Initialized widgets are objects</a></h2>
<p>As for what that means to us, <code>GObjects</code> are heap-allocated with interior mutability. Behaviorally, they operate very similarly to how you would expect to work with a <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> type in Rust. You'll never be required to have unique ownership or a mutable reference to modify a widget, as a result.</p>
<p>When you clone a GObject, you are creating a new strong reference to the object. When all strong references have been dropped, the destructor for that object is run. However, cyclic references are possible with strong references which can prevent the strong count from ever reaching 0, so there's an option to downgrade them into a weak reference. We'll be designing our software in a way that mitigates the need for this though.</p>
<h2 id="widgets-have-inheritance"><a class="header" href="#widgets-have-inheritance">Widgets have inheritance</a></h2>
<p>Being built in an object-oriented fashion, widgets are built by inheriting other widgets. So a <code>gtk::Box</code> is a subclass of <code>gtk::Container</code>, which is also a subclass of <code>gtk::Widget</code>; and therefore we can downgrade a <code>gtk::Box</code> into a <code>gtk::Container</code>, and we can further downgrade that into a <code>gtk::Widget</code>.</p>
<p>There may be times when an API hands you a <code>gtk::Widget</code>, and you'll need to upgrade that widget into a more specific type of widget if you want to access methods from that widget's class.</p>
<p>Or there may also be times when you just want to simplify your code and downgrade a widget into a <code>gtk::Widget</code> because you're passing it onto something that takes any kind of widget as an input.</p>
<h2 id="widget-classes-have-traits"><a class="header" href="#widget-classes-have-traits">Widget classes have traits</a></h2>
<p>In the GTK-rs implementation, methods from classes are conveniently stored in traits. The <code>gtk::Widget</code>, <code>gtk::Container</code>, and <code>gtk::Box</code> classes have their methods stored in their respective <code>gtk::WidgetExt</code>, <code>gtk::ContainerExt</code>, and <code>gtk::BoxExt</code> traits. This will allow you to conveniently handle your widgets in a generic fashion. Maybe you have a function that can be perfectly written as <code>fn function&lt;W: WidgetExt&gt;(widget: &amp;W) {}</code>,</p>
<h2 id="gtk-is-not-thread-safe"><a class="header" href="#gtk-is-not-thread-safe">GTK is not thread-safe</a></h2>
<p>Finally, although GObjects can be thread-safe, GTK widgets are most definitely not. You should not attempt to send GTK widgets across thread boundaries, which thankfully the Rust type system will not permit. GTK widgets must be created and interacted with exclusively on the thread that GTK was initialized on.</p>
<p>There are crates such as <code>fragile</code> that would allow you to wrap your widgets into a <code>Fragile&lt;T&gt;</code> and send them across threads, but this is most certainly an anti-pattern. The way a <code>Fragile&lt;T&gt;</code> works is that it prevents you from accessing the <code>T</code> inside the wrapper unless you are unwrapping it from the same thread that it was created on. If you design your software correctly, you won't have to resort to this kind of arcane magic. Turn back before it is too late.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>Before we begin, ensure that you have the necessary development files installed for GTK. On Debian platforms, you will need:</p>
<ul>
<li><code>libgtk-3-dev</code> for GTK3</li>
<li><code>libgtk-4-dev</code> for GTK4</li>
<li><code>libwebkit2gtk-4.0-dev</code> if embedding a GTK WebKit View</li>
<li><code>libgtksourceview-4-dev</code> if embedding a GTK Source View</li>
</ul>
<p>On the Rust side of things, you should install:</p>
<ul>
<li><code>cargo-edit</code> with <code>cargo install cargo-edit</code>, because that'll make adding dependencies to your project easier.</li>
<li><code>rust-analyzer</code> in your IDE so that you'll have instant feedback about warnings and errors as you type</li>
</ul>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<p>The API documentation generated on <a href="https://docs.rs">docs.rs</a> lacks descriptions of the APIs. If you want the most complete API documentation, you will need to reference the documentation generated on the gtk-rs website <a href="https://gtk-rs.org/docs-src/">here</a>.</p>
<p>To navigate this API, every widget has its own type, but those types only contain methods for constructing the widget. Methods specific to each widget can be found in the <code>Ext</code> trait for that widget, such as <code>ButtonExt</code>. You may reference the widget type to see what behaviors it implements, such as <code>ContainerExt</code> or <code>WidgetExt</code>.</p>
<p>Finally, each widget also has a <code>Builder</code> type, such as <code>ButtonBuilder</code>. In some cases, the builder type will be the only way to achieve a certain desired effect, such creating a dialog with a <code>gtk::HeaderBar</code>. This is because this method will define each property before the widget is initialized.</p>
<h2 id="cascade-macro"><a class="header" href="#cascade-macro">Cascade Macro</a></h2>
<p>This macro is an alternative to the builder pattern that I find more useful in general, as the builder type only works up to creation of the widget, rather than calling methods on created widget itself — such as adding widgets to a container.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = cascade! {
    gtk::Box::new(gtk::Orientation::Vertical, 0);
    ..add(&amp;widget1);
    ..add(&amp;widget2);
};
<span class="boring">}
</span></code></pre></pre>
<p>Essentially, the first statement creates your widget, and following lines that start with <code>.</code> will allow you to invoke a method on that widget, before finally returning the widget itself.</p>
<h2 id="creating-your-project"><a class="header" href="#creating-your-project">Creating Your Project</a></h2>
<p>Now we're going to start the process of actually building our first GTK application. Create your project, and add the following dependencies that we need to get started:</p>
<pre><code>cargo new first-gtk-app
cd first-gtk-app
cargo add gtk glib async-channel cascade
</code></pre>
<h3 id="initializing-gtk"><a class="header" href="#initializing-gtk">Initializing GTK</a></h3>
<p>Now we're ready to start with code. Lets start by setting your application's name, and initializing GTK.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate cascade;

use gtk::prelude::*;
use std::process;

fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-glib-as-an-async-runtime"><a class="header" href="#using-glib-as-an-async-runtime">Using GLib as an Async Runtime</a></h1>
<p>Before moving further, we should know that we can leverage the same async runtime that GTK uses for spawning and scheduling its tasks.</p>
<h2 id="spawning-tasks-on-the-default-executor"><a class="header" href="#spawning-tasks-on-the-default-executor">Spawning tasks on the default executor</a></h2>
<p>This will schedule our futures to execute on the main thread, alongside all of the futures scheduled by GTK itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

/// Spawns a task on the default executor and waits to receive its output
pub fn block_on&lt;F&gt;(future: F) -&gt; F::Output where F: Future {
    glib::MainContext::default().block_on(future)
}

/// Spawns a task in the background on the default executor
pub fn spawn&lt;F&gt;(future: F) where F: Future&lt;Output = ()&gt; + 'static {
    glib::MainContext::default().spawn_local(future);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="spawning-tasks-on-the-current-threads-executor"><a class="header" href="#spawning-tasks-on-the-current-threads-executor">Spawning tasks on the current thread's executor</a></h2>
<p>Using this approach, you can spawn futures onto the executor that is registered to the thread you are blocking from. By default, there is no executor initialized for newly-spawned threads, so you'll have to create and assign them to the current thread when <code>glib::MainContext::thread_default()</code> returns <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

pub fn thread_context() -&gt; glib::MainContext {
    glib::MainContext::thread_default()
        .unwrap_or_else(|| {
            let ctx = glib::MainContext::new();
            ctx.push_thread_default();
            ctx
        })
}

pub fn block_on&lt;F&gt;(future: F) -&gt; F::Output where F: Future {
    thread_context().block_on(future)
}

pub fn spawn&lt;F&gt;(future: F) where F: Future&lt;Output = ()&gt; + 'static {
    thread_context().spawn_local(future);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="spawning-tasks-on-a-background-thread"><a class="header" href="#spawning-tasks-on-a-background-thread">Spawning tasks on a background thread</a></h2>
<p>This is useful if you spawn a background thread and want to execute your futures using a GLib executor on that thread.</p>
<pre><pre class="playground"><code class="language-rust">use std::future::Future;

pub fn thread_context() -&gt; glib::MainContext {
    glib::MainContext::thread_default()
        .unwrap_or_else(|| {
            let ctx = glib::MainContext::new();
            ctx.push_thread_default();
            ctx
        })
}

pub fn block_on&lt;F&gt;(future: F) -&gt; F::Output where F: Future {
    thread_context().block_on(future)
}

enum BackgroundEvent { DoThis }

fn main() {
    let (bg_tx, bg_rx) = async_channel::unbounded();

    std::thread::spawn(|| {
        block_on(async move {
            while let Ok(request) = bg_rx.recv().await {
                match request {
                    BackgroundEvent::DoThis =&gt; do_this().await,

                }
            }
        });
    });
}
</code></pre></pre>
<h2 id="spawning-tasks-on-a-thread-pool"><a class="header" href="#spawning-tasks-on-a-thread-pool">Spawning tasks on a thread pool</a></h2>
<p>There is also an option of using <code>glib::ThreadPool</code>, which gives you exactly that. It defaults to the number of virtual CPU cores in the system, and by default parks threads that have been idle for more than 15 seconds. The pool does not have a requirement on mutability for spawning blocking tasks, so you can initialize this as a global variable using <code>once_cell::sync::Lazy</code> to use around your application, if you prefer this over a Rust-native thread pool like <code>rayon</code>. Perhaps to leverage system libraries.</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use std::thread::sleep;

fn main() {
    let pool = glib::ThreadPool::new_shared(None)
        .expect(&quot;failed to spawn thread pool&quot;);

    let _ = pool.push(|| {
        sleep(Duration::from_secs(1));
        println!(&quot;First Task&quot;);
    });

    let _ = pool.push(|| {
        sleep(Duration::from_secs(2));
        println!(&quot;Second Task&quot;);
    });

    let _ = pool.push(|| {
        sleep(Duration::from_secs(3));
        println!(&quot;Third Task&quot;);
    });

    // Wait for tasks to complete
    while pool.get_unprocessed() &gt; 0 {
        sleep(Duration::from_secs(1));
    }
}
</code></pre></pre>
<h2 id="spawning-futures-on-a-glibthreadpool"><a class="header" href="#spawning-futures-on-a-glibthreadpool">Spawning futures on a glib::ThreadPool</a></h2>
<p>However, this thread pool takes closures as inputs, rather than futures. So if you want to use for futures, you can combine it with the thread default executor above.</p>
<pre><pre class="playground"><code class="language-rust">use async_io::Timer;
use std::time::Duration;
use std::thread::sleep;
use std::future::Future;

fn thread_context() -&gt; glib::MainContext {
    glib::MainContext::thread_default()
        .unwrap_or_else(|| {
            let ctx = glib::MainContext::new();
            ctx.push_thread_default();
            ctx
        })
}

fn block_on&lt;F&gt;(future: F) -&gt; F::Output where F: Future {
    thread_context().block_on(future)
}

fn main() {
    let pool = glib::ThreadPool::new_shared(None)
        .expect(&quot;failed to spawn thread pool&quot;);

    let _ = pool.push(|| {
        block_on(async {
            Timer::after(Duration::from_secs(1)).await;
            println!(&quot;First Task&quot;);
        })
    });

    let _ = pool.push(|| {
        block_on(async {
            Timer::after(Duration::from_secs(2)).await;
            println!(&quot;Second Task&quot;);
        })
    });

    let _ = pool.push(|| {
        block_on(async {
            Timer::after(Duration::from_secs(3)).await;
            println!(&quot;Third Task&quot;);
        })
    });

    // Wait for tasks to complete
    block_on(async {
        while pool.get_unprocessed() &gt; 0 {
            Timer::after(Duration::from_secs(1)).await;
        }
    })
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-driven-approach"><a class="header" href="#event-driven-approach">Event-Driven Approach</a></h1>
<p>In the event-driven approach, event handlers will capture and control access to application state. Widgets will have their signals connected to send events through a channel to these event handlers, without access to the global application state themselves. States can be moved and exclusively owned by their respective event handlers; thereby eliminating the need for reference counters, or the need to share your application states with every widget's signal.</p>
<h2 id="setting-it-up"><a class="header" href="#setting-it-up">Setting it up</a></h2>
<p>To achieve this, we need an async channel that we can get from the <code>async-channel</code> crate:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (tx, rx) = async_channel::unbounded();
<span class="boring">}
</span></code></pre></pre>
<p>Now we need some event variants that our channel will emit:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Event {
    Clicked
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we will attach the receiver to a future which merely loops on our receiver forever:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_handler = async move {
    while let Ok(event) = rx.recv().await {
        match event {
            Event::Clicked =&gt; {

            }
        }
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>And spawn this event handler on the default executor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GLib has an executor in the background that will
// asynchronously handle our events on this thread
glib::MainContext::default().spawn_local(event_handler);
<span class="boring">}
</span></code></pre></pre>
<p>Your source code should now look like so, and you are now ready to continue to setting up a window with a clickable button.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate cascade;

use gtk::prelude::*;
use std::process;

enum Event {
    Clicked
}

fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Attach `tx` to our widgets, and `rx` to our event handler
    let (tx, rx) = async_channel::unbounded();

    // Processes all application events received from signals
    let event_handler = async move {
        while let Ok(event) = rx.recv().await {
            match event {
                Event::Clicked =&gt; {

                }
            }
        }
    };

    // GLib has an executor in the background that will
    // asynchronously handle our events on this thread
    glib::MainContext::default().spawn_local(event_handler);

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<h2 id="avoid-blocking-the-default-executor"><a class="header" href="#avoid-blocking-the-default-executor">Avoid blocking the default executor</a></h2>
<p>Take careful note that because this async task has been spawned on the same executor as all of GTK's own tasks, you must be careful to avoid doing anything that would block your event handler. If your event handler were to block, the default <code>MainContext</code> would block with it, thereby freezing the GUI.</p>
<p>Tasks that require a lot of CPU and/or I/O should be performed in a background thread. Generally, the only code that should be executed on the default context is code that interacts directly with the widgets — fetching information from widgets, creating new widgets, and updating existing ones.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-window-with-a-button"><a class="header" href="#creating-a-window-with-a-button">Creating a Window with a Button</a></h1>
<p>Let's start by setting up a convenience function for spawning futures on the default executor. This will be necessary to send messages through the async channel.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

/// Spawns a task on the default executor, without waiting for it to complete
pub fn spawn&lt;F&gt;(future: F) where F: Future&lt;Output = ()&gt; + 'static {
    glib::MainContext::default().spawn_local(future);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="creating-the-app-struct"><a class="header" href="#creating-the-app-struct">Creating the App struct</a></h2>
<p>I typically have a single <code>App</code> struct where all application state and GTK widgets that are regularly interacted with are stored. We're going to start with a struct that contains a <code>gtk::Button</code> and a <code>u32</code> &quot;clicked&quot; variable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_channel::Sender;

struct App {
    pub button: gtk::Button,
    pub clicked: u32,
}

impl App {
    pub fn new(tx: Sender&lt;Event&gt;) -&gt; Self {}
}
<span class="boring">}
</span></code></pre></pre>
<p>When creating the application, we will take ownership of the <code>Sender</code> that we created earlier, and pass this into every <code>.connect_signal()</code> method that is called on a widget. The <code>.connect_signal()</code> methods will create a future on the main context that idles until the condition for that future has been emitted. A <code>gtk::Button</code>, for example, has a <code>.connect_clicked()</code> method which will have its callbacks invoked when <code>clicked</code> is emitted — which happens on a click of the button.</p>
<p>Note that you may connect multiple callbacks onto the same signal. If you wish to remove one, you should be careful to store the <code>SignalHandlerId</code> that is returned from the <code>.connect_signal()</code> method. Then call <code>widget.disconnect(id)</code> to remove the signal registered to that widget. If you only wish to temporarily block a signal, you can call <code>widget.block_signal(id)</code> and <code>widget.unblock_signal(id)</code> respectively.</p>
<h2 id="creating-widgets-for-our-app"><a class="header" href="#creating-widgets-for-our-app">Creating widgets for our app</a></h2>
<p>First, we will create the button that we will have the user click. The button will have a label which reads, &quot;Click Me&quot;. The border will be set to 4 so that the button isn't hugging the edges of the container it is attached to. And then will program it to send an event when it is clicked.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let button = cascade! {
    gtk::Button::with_label(&quot;Click Me&quot;);
    ..set_border_width(4);
    ..connect_clicked(move |_| {
        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::Clicked).await;
        });
    });
};
<span class="boring">}
</span></code></pre></pre>
<p>Note that since we are using an async channel, the sender has to be awaited when it is sending a value. We can use GLib's default executor to await our send.</p>
<blockquote>
<p>If the sender happens to block, it could block the default executor and thereby freeze the application. If you're using an unbounded receiver, it will never block on a send, so you will not have to worry about this.</p>
<p>When using a bounded receiver, you should ensure that the tasks is spawned on the executor so that at least the sender can safely wait for its turn to send without blocking our application. However, there is no reason to use a bounded receiver for receiving events, because you'll simply cause the executor to fill up with unresolved tasks.</p>
</blockquote>
<p>Next is creating a container widget to hold our button. This container will also invoke <code>.show_all()</code> to make the container visible, and all of the widgets inside the container.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = cascade! {
    gtk::Box::new(gtk::Orientation::Vertical, 0);
    ..add(&amp;button);
    ..show_all();
};
<span class="boring">}
</span></code></pre></pre>
<h2 id="creating-the-window"><a class="header" href="#creating-the-window">Creating the window</a></h2>
<p>Next we we will create the <code>Toplevel</code> window for this application, and attach our container to the window. We will set a title, connect the event to be called when window is deleted, and also set the default icon for our application. The <code>Toplevel</code> window is the main window of your application. A window can only have one widget attached to it, which we will assign with the <code>.add()</code> method. The <code>.set_title()</code> method will set the title of your application. The <code>.connect_delete_event</code> method is invoked whenever the window is destroyed, and we will program this to call <code>gtk::main_quit()</code> to stop the mainloop, thereby having <code>gtk::main()</code> return, which has our application quit.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _window = cascade! {
    gtk::Window::new(gtk::WindowType::Toplevel);
    ..add(&amp;container);
    ..set_title(&quot;First GTK App&quot;);
    ..set_default_size(300, 400);
    ..connect_delete_event(move |_, _| {
        gtk::main_quit();
        gtk::Inhibit(false)
    });
    ..show_all();
};
<span class="boring">}
</span></code></pre></pre>
<p>One last thing that should be done for window managers is to set a default icon for the application:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can finally return our <code>App</code> struct, which should look like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl App {
    pub fn new(tx: Sender&lt;Event&gt;) -&gt; Self {
        let button = cascade! {
            gtk::Button::with_label(&quot;Click Me&quot;);
            ..set_border_width(4);
            ..connect_clicked(move |_| {
                let tx = tx.clone();
                spawn(async move {
                    let _ = tx.send(Event::Clicked).await;
                });
            });
        };

        let container = cascade! {
            gtk::Box::new(gtk::Orientation::Vertical, 0);
            ..add(&amp;button);
            ..show_all();
        };

        let _window = cascade! {
            gtk::Window::new(gtk::WindowType::Toplevel);
            ..set_title(&quot;First GTK App&quot;);
            ..add(&amp;container);
            ..connect_delete_event(move |_, _| {
                gtk::main_quit();
                gtk::Inhibit(false)
            });
            ..show_all();
        };

        gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);

        Self { button, clicked: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="responding-to-the-clicked-event"><a class="header" href="#responding-to-the-clicked-event">Responding to the clicked event</a></h2>
<p>In the example below, you can see that we have passed ownership of the <code>App</code> into the event handler. The <code>clicked</code> property is incremented whenever we receive <code>Event::Clicked</code>. The button's label is updated to show how many times it has been clicked.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    glib::set_program_name(&quot;First GTK App&quot;.into());
    glib::set_application_name(&quot;First GTK App&quot;);

    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Attach `tx` to our widgets, and `rx` to our event handler
    let (tx, rx) = async_channel::unbounded();

    let mut app = App::new(tx);

    // Processes all application events received from signals
    let event_handler = async move {
        while let Ok(event) = rx.recv().await {
            match event {
                Event::Clicked =&gt; {
                    app.clicked += 1;
                    app.button.set_label(&amp;format!(&quot;I have been clicked {} times&quot;, app.clicked));
                }
            }
        }
    };

    // GLib has an executor in the background that will
    // asynchronously handle our events on this thread
    glib::MainContext::default().spawn_local(event_handler);

    // Thread will block here until the application is quit
    gtk::main();
}
</code></pre></pre>
<p>You may run the application with <code>cargo run</code> and try it out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtk-widget-reference"><a class="header" href="#gtk-widget-reference">GTK Widget Reference</a></h1>
<p>List of roughly every widget included in GTK</p>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>Containers control the behavior and layout of the widgets within them.</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.AspectFrame.html">AspectFrame</a>: Ensures that the widget retains the same aspect when resized</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Box.html">Box</a>: Lays widgets in vertical or horizontal layouts</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ButtonBox.html">ButtonBox</a>: Arranges buttons within the container, and themes may style buttons packed this way in a nicer way</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Expander.html">Expander</a>: Shows/hides a widget with a button that expands to reveal a hidden widget</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.FlowBox.html">FlowBox</a>: Lays widgets horizontally, and dynamically shifts them to new rows as the parent container shrinks</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Frame.html">Frame</a>: Displays a frame around a widget</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Grid.html">Grid</a>: Lays widgets within a grid of rows and columns, with each widget occupying a X,Y position with a defined width and height</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.HeaderBar.html">HeaderBar</a>: Replaces the title bar, where widgets can be packed from the start, the center, or the end of the bar</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Notebook.html">Notebook</a>: Identical to a stack, but has tabs for switching between widgets. Essentially a Stack + StackSwitcher with a set style</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Paned.html">Paned</a>: Containers two widgets side-by-side with a boundary between them that allows the user to resize between them</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Revealer.html">Revealer</a>: Conceals and reveals a widget with an animation</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ScrolledWindow.html">ScrolledWindow</a>: Makes the contained widget scrollable</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Stack.html">Stack</a>: Stores multiple widgets, but only one widget is shown at a time. May be combined with a StackSwitcher to have tabs</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Toolbar.html">Toolbar</a>: Bar at the top of the window for containing tool items</li>
</ul>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Containers with selectable widgets</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ComboBox.html">ComboBox</a>: Used in conjuction with a tree model to show a list of options to select from</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ComboBoxText.html">ComboBoxText</a>: Streamlined variant of a ComboBox to choose from a list of text options</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.IconView.html">IconView</a>: Think of a file browser with mouse drag selections. Essentially a FlowBox-like container with a grid of icons with text</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ListBox.html">ListBox</a>: Each widget is an interactive row in a list, which may be activated or clicked, and may support multiple selections</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.TreeView.html">TreeView</a>: Used to present tabular data, with each row being an object in the list, and each column a field of that object</li>
</ul>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<p>Containers which display or receive text</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Label.html">Label</a>: Displays text without any ability to copy or edit the text</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Entry.html">Entry</a>: Text box for a single line of text</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.TextView.html">TextView</a>: Multi-line text box</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.SearchEntry.html">SearchEntry</a>: Entry designed for use for searches</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.SearchBar.html">SearchBar</a>: Toolbar that reveals a search entry when the user starts typing</li>
</ul>
<h2 id="buttons"><a class="header" href="#buttons">Buttons</a></h2>
<p>Widgets that can be clicked or activated by keyboard</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.AppChooserButton.html">AppChooserButton</a>: Button that shows an app chooser dialog</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Button.html">Button</a>: Interactive widget that may contain text, an image, or other widgets</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.CheckButton.html">CheckButton</a>: Check mark with a label that can be toggled on/off</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ColorButton.html">ColorButton</a>: Displays a color and shows a color chooser dialog to select a different one</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.FileChooserButton.html">FileChooserButton</a>: Shows a file chooser dialog to select file(s) or folder(s)</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.FontButton.html">FontButton</a>: Displays a font and shows a font chooser dialog ot select a different one</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.LinkButton.html">LinkButton</a>: Hyperlink text button for linking to a URI</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.LockButton.html">LockButton</a>: Button with a lock icon for unlocking / locking privileged options</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.MenuButton.html">MenuButton</a>: Button for showing a popover menu on click</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.RadioButton.html">RadioButton</a>: When grouped with other radio buttons, only one button may be activate</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ScaleButton.html">ScaleButton</a>: Button that pops up a scale</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.SpinButton.html">SpinButton</a>: Number entry with buttons for incrementing and decrementing</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.StackSidebar.html">StackSidebar</a>: Vertical tabs for a stack</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.StackSwitcher.html">StackSwitcher</a>: Horizontal tabs for a stack</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Switch.html">Switch</a>: Toggle button represented as an off/on switch</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ToggleButton.html">ToggleButton</a>: Button that toggles between being pressed in and unpressed</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.VolumeButton.html">VolumeButton</a>: Button that pops up a volume scale</li>
</ul>
<h2 id="display"><a class="header" href="#display">Display</a></h2>
<p>Widgets that display things</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.DrawingArea.html">DrawingArea</a>: Provides a canvas for drawing images onto</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.EventBox.html">EventBox</a>: Makes it possible for a widget to receive button / mouse events</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.GLArea.html">GLArea</a>: Context for rendering OpenGL onto</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Image.html">Image</a>: Displays a picture</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.InfoBar.html">InfoBar</a>: Hidden bar that is revealed when info or an error is to be shown</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.LevelBar.html">LevelBar</a>: Shows a level of a scale</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ProgressBar.html">ProgressBar</a>: Shows a progress bar</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Separator.html">Separator</a>: Shows a horizontal or vertical separator</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.ShortcutLabel.html">ShortcutLabel</a>: Keyboard shortcut label</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Spinner.html">Spinner</a>: Shows a spinning animation</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Statusbar.html">Statusbar</a>: Displays information at the bottom of the window</li>
</ul>
<h2 id="misc"><a class="header" href="#misc">Misc</a></h2>
<p>Everything else</p>
<ul>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.PlacesSidebar.html">PlacesSidebar</a>: Displays frequently visited places in the file system</li>
<li><a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Plug.html">Plug</a> / <a href="https://gtk-rs.org/gtk3-rs/stable/latest/docs/gtk/struct.Socket.html">Socket</a>: Allows sharing widgets across windows</li>
</ul>
<blockquote>
<p>An exhaustive list of the gtk widgets can be found in the <a href="https://docs.gtk.org/gtk4/visual_index.html">widget gallery</a>, but the API version is GTK 4 and above, so crosscheck with the GTK3 docs to get the correct syntax for a widget</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">ToDo</a></h1>
<blockquote>
<p>Full source code for this chapter can be found in the <a href="https://github.com/mmstick/gtkrs-tutorials">GitHub Repository</a> under <code>examples/02-Todo</code>.</p>
</blockquote>
<p>The first application that we will create in this tutorial series is a ToDo list. There are a myriad of ways to create them, but we are going to opt for the event-driven approach with a <a href="https://docs.rs/slotmap">slotmap</a>. Each task in the ToDo list will be stored in the SlotMap and referenced by its key. On launch of the application, we will load the most-recently modified note. On close, we will write any changes that have yet to be saved before quitting the application. We will also save any changes made every 5 seconds after the last modification.</p>
<h2 id="what-is-a-slotmap"><a class="header" href="#what-is-a-slotmap">What is a SlotMap?</a></h2>
<p>SlotMap is described as a &quot;container with persistent unique keys to access stored values.&quot; Essentially, it is an arena allocator with generational indices. Imagine a vector where each slot contains a version number. Odd-numbered versions indicate to the allocator that the slot is empty and ready to be filled. On insertion of a new value into a slot, the version is incremented back to an even number, and a key is returned which contains the &quot;generation&quot; version, and the indice of the slot that was used. This gives SlotMap roughly the same performance as accessing an element of an array by its indice, but with an additional version check to determine if key is still valid.</p>
<h2 id="initialize-the-project"><a class="header" href="#initialize-the-project">Initialize the project</a></h2>
<p>To get started, create a new project:</p>
<pre><code>cargo new todo
cd todo
cargo add async-channel cascade fomat-macros gio glib gtk slotmap xdg
</code></pre>
<p>Then inside the src folder, structure your project like so:</p>
<pre><code>src/
    app.rs
    background.rs
    main.rs
    utils.rs
    widgets.rs
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-gtkapplication"><a class="header" href="#using-gtkapplication">Using gtk::Application</a></h1>
<h2 id="utilsrs"><a class="header" href="#utilsrs">utils.rs</a></h2>
<p>Before we begin, we need to add some utility functions that we'll be using throughout the application. We will be spawning a background thread and executing tasks on it, so we'll need a convenience function for fetching the thread-default context. Likewise, we're going to spawning tasks on the global default context, so we'll need that here as well.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

pub fn thread_context() -&gt; glib::MainContext {
    glib::MainContext::thread_default()
        .unwrap_or_else(|| {
            let ctx = glib::MainContext::new();
            ctx.push_thread_default();
            ctx
        })
}

pub fn spawn&lt;F&gt;(future: F) where F: Future&lt;Output = ()&gt; + 'static {
    glib::MainContext::default().spawn_local(future);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="mainrs"><a class="header" href="#mainrs">main.rs</a></h2>
<p>This time we will create a GTK application using the proper <code>gtk::Application</code> setup process. This will take care of initializing GTK for you, and registers your application with an application ID so that you can prevent your application from spawning multiple instances.</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use]
extern crate cascade;

mod app;
mod background;
mod widgets;
mod utils;

use self::app::App;
use gio::prelude::*;

/// The name that we will register to the system to identify our application
pub const APP_ID: &amp;str = &quot;io.github.mmstick.ToDo&quot;;

fn main() {
    let app_name = &quot;Todo&quot;;

    glib::set_program_name(Some(app_name));
    glib::set_application_name(app_name);

    // Initializes GTK and registers our application. gtk::Application helps us
    // set up an application with less work
    let app = gtk::Application::new(
        Some(APP_ID),
        Default::default()
    ).expect(&quot;failed to init application&quot;);

    // After the application has been registered, it will trigger an activate
    // signal, which will give us the okay to construct our application and set
    // up our application logic. We're going to use `app` to create the
    // application window in the future.
    app.connect_activate(|app| {
        let (tx, rx) = async_channel::unbounded();

        let mut app = App::new(app, tx);

        let event_handler = async move {
            while let Ok(event) = rx.recv().await {
                match event {

                }
            }
        };

        utils::spawn(event_handler);
    });

    // This last step performs the same duty as gtk::main()
    app.run(&amp;[]);
}
</code></pre></pre>
<p>Calling <code>gtk::Application::new()</code> will run <code>gtk::init()</code> and register your application by the <code>APP_ID</code> that we defined. The general practice for application IDs is to use <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">Reverse domain name notation (RDNN)</a>. <code>gtk::Application::connect_activate()</code> signals that GTK is ready for us to construct our application window and set up all of our application logic. This method receives a reference to the <code>gtk::Application</code> itself, which we will later use to create the <code>gtk::ApplicationWindow</code>, which is our top level <code>gtk::Window</code> for our application. <code>gtk::Application::run()</code> will then invoke <code>gtk::main()</code> to set the whole process in motion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modeling-our-events"><a class="header" href="#modeling-our-events">Modeling Our Events</a></h1>
<p>Before going to the next step, we need to think about how we will design our application, and what events our application is going to handle.</p>
<p>A ToDo application will have the following behaviors:</p>
<ul>
<li>Insert a task</li>
<li>Remove a task</li>
</ul>
<p>Each task will be represented in our UI as a row containing the following widgets: A <code>gtk::Entry</code> for writing our task notes; with two <code>gtk::Button</code>s for inserting a new task below, or removing the task in that row. Our tasks will be stored in a <code>SlotMap</code>, where each task is referenced by their custom key: <code>TaskEntity</code>.</p>
<ul>
<li>Load tasks from a file</li>
</ul>
<p>When we load our notes from a file, it will be in the form of a <code>String</code>, and each task will be a separate line in that string. The application will automatically create a new task row for each line in that string.</p>
<ul>
<li>Notify when a task is modified</li>
<li>Save tasks to a file</li>
</ul>
<p>Every 5 seconds after the last modification, we will fetch the contents of each <code>gtk::Entry</code> and save them to a file. We will also save the contents of each widget when the application has been closed.</p>
<ul>
<li>Notify that the application has been closed</li>
<li>Notify that we are ready to quit</li>
</ul>
<p>The last two events are an important distinction. When the GTK application has been closed, we will get notified that it has been destroyed. During that time, we will schedule to have our notes saved, and quit the application once they've been saved to the disk.</p>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1">main.rs</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a key type to identify the keys that we'll use for the Task SlotMap.
slotmap::new_key_type! {
    pub struct TaskEntity;
}

pub enum Event {
    // Insert a task below the given task, identified by its key
    Insert(TaskEntity),

    // A previous task list has been fetched from a file from the background
    // thread, and it is now our job to display it in our UI.
    Load(String),

    // Signals that an entry was modified, and at some point we should save it
    Modified,

    // Removes the task identified by this entity
    Remove(TaskEntity),

    // Signals that we should collect up the text from each task and pass it
    // to a background thread to save it to a file.
    SyncToDisk,

    // Signals that the window has been closed, so we should clean up and quit
    Closed,

    // Signals that the process has saved to disk and it is safe to exit
    Quit,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then modify our event handler like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event_handler = async move {
    while let Ok(event) = rx.recv().await {
        match event {
            Event::Modified =&gt; app.modified(),
            Event::Insert(entity) =&gt; app.insert(entity),
            Event::Remove(entity) =&gt; app.remove(entity),
            Event::SyncToDisk =&gt; app.sync_to_disk().await,
            Event::Load(data) =&gt; app.load(data),
            Event::Closed =&gt; app.closed().await,
            Event::Quit =&gt; gtk::main_quit(),
        }
    }
};
<span class="boring">}
</span></code></pre></pre>
<p>Events are listed in the order that they are most-likely to be called in, with the most-called events first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-and-saving-in-the-background"><a class="header" href="#loading-and-saving-in-the-background">Loading and Saving in the Background</a></h1>
<h2 id="mainrs-2"><a class="header" href="#mainrs-2">main.rs</a></h2>
<p>To handle events in the background, and within the app itself, we will need two separate channels. One receiver will listen for application events in the main thread which manages the UI. The other receiver will listen for events from the application in a background thread.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Channel for UI events in the main thread
let (tx, rx) = async_channel::unbounded();

// Channel for background events to the background thread
let (btx, brx) = async_channel::unbounded();
<span class="boring">}
</span></code></pre></pre>
<p>Reading and writing data to a file is a blocking operation that has risk of freezing the application when these operations are occurring on the same thread as the UI. We can therefore avoid hanging the UI simply by passing these tasks off to a background thread.</p>
<h2 id="spawning-the-background-thread"><a class="header" href="#spawning-the-background-thread">Spawning the background thread</a></h2>
<p>Next we will spawn a thread, and pass both a clone of our application event sender, and the background event receiver. The glib crate provides a <a href="https://gtk-rs.org/docs/glib/macro.clone.html#passing-a-strong-reference">clone macro</a> which can be used</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Take ownership of a copy of the UI event sender (tx),
// and the background event receiver (brx).
std::thread::spawn(glib::clone!(@strong tx =&gt; move || {
    // Fetch the executor registered for this thread
    utils::thread_context()
        // Block this thread on an event loop future
        .block_on(background::run(tx, brx));
}));
<span class="boring">}
</span></code></pre></pre>
<p>We're going to attach the background sender to our <code>App</code> in the future, so we need to update our call to <code>App::new()</code> to take both channels as input parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut app = App::new(app, tx, btx);
<span class="boring">}
</span></code></pre></pre>
<h2 id="backgroundrs"><a class="header" href="#backgroundrs">background.rs</a></h2>
<p>Our background event loop is going to start with an async function that looks like this. It all take a sender for events we need to pass back to the UI, and the receiver for receiving events from the UI.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::Event;
use async_channel::{Receiver, Sender};
use std::path::{Path, PathBuf};
use std::time::SystemTime;
use std::{fs, io};

pub async fn run(tx: Sender&lt;Event&gt;, rx: Receiver&lt;BgEvent&gt;) {

}
<span class="boring">}
</span></code></pre></pre>
<h3 id="xdg"><a class="header" href="#xdg">XDG</a></h3>
<p>On first startup, our application will load the most recently-modified task in memory. Applications should adhere to the XDG standards when they are making decisions about where to store files used by their application. Using the <code>xdg</code> crate, we can get the prefix for your application with the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xdg_dirs = xdg::BaseDirectories::with_prefix(crate::APP_ID)
    .unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Because the directory will not exist on a first startup, we need to ensure it's created:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data_home = xdg_dirs.get_data_home();

let _ = fs::create_dir_all(&amp;data_home);
<span class="boring">}
</span></code></pre></pre>
<p>With the data directory for our app now created, we'll search it for the most recently-created file in this directory, and read that file into memory to pass back to our app:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(path) = most_recent_file(&amp;data_home).unwrap() {
    if let Ok(data) = std::fs::read_to_string(&amp;path) {
        let _ = tx.send(Event::Load(data)).await;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="fetching-the-most-recent-file"><a class="header" href="#fetching-the-most-recent-file">Fetching the most-recent file</a></h3>
<p>The function, <code>most_recent_file()</code> contains the following for reference:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn most_recent_file(path: &amp;Path) -&gt; io::Result&lt;Option&lt;PathBuf&gt;&gt; {
    let mut most_recent = SystemTime::UNIX_EPOCH;
    let mut target = None;

    for entry in fs::read_dir(path)?.filter_map(Result::ok) {
        if entry.file_type().map_or(false, |kind| kind.is_file()) {
            if let Ok(modified) = entry.metadata()
                .and_then(|m| m.modified())
            {
                if modified &gt; most_recent {
                    target = Some(entry.path());
                    most_recent = modified;
                }
            }
        }
    }

    Ok(target)
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="handling-events"><a class="header" href="#handling-events">Handling Events</a></h3>
<p>And then finally, we will start handling the events we receive from the UI. The first being a request to save notes to a file, and the other a request to quit the application.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Events that the background thread's event loop will respond to
pub enum BgEvent {
    // Save tasks to a file
    Save(PathBuf, String),

    // Exit the from the event loop
    Quit
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Quit</code> event will break from the event loop and then reply to the application that we have finished any task we were waiting on, and it is now safe to exit the application.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Ok(event) = rx.recv().await {
    match event {
        BgEvent::Save(path, data) =&gt; {
            let path = xdg_dirs.place_data_file(path).unwrap();
            std::fs::write(&amp;path, data.as_bytes()).unwrap();
        },

        BgEvent::Quit =&gt; break
    }
}

let _ = tx.send(Event::Quit).await;
<span class="boring">}
</span></code></pre></pre>
<h3 id="review"><a class="header" href="#review">Review</a></h3>
<p>At the end, your file should look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn run(tx: Sender&lt;Event&gt;, rx: Receiver&lt;BgEvent&gt;) {
    let xdg_dirs = xdg::BaseDirectories::with_prefix(crate::APP_ID).unwrap();

    let data_home = xdg_dirs.get_data_home();

    let _ = fs::create_dir_all(&amp;data_home);

    if let Some(path) = most_recent_file(&amp;data_home).unwrap() {
        if let Ok(data) = std::fs::read_to_string(&amp;path) {
            let _ = tx.send(Event::Load(data)).await;
        }
    }

    while let Ok(event) = rx.recv().await {
        match event {
            BgEvent::Save(path, data) =&gt; {
                let path = xdg_dirs.place_data_file(path).unwrap();
                std::fs::write(&amp;path, data.as_bytes()).unwrap();
            },

            BgEvent::Quit =&gt; break
        }
    }

    let _ = tx.send(Event::Quit).await;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-task-widget-struct"><a class="header" href="#creating-the-task-widget-struct">Creating the Task Widget Struct</a></h1>
<p>Before we work on the core of the application itself, I typically start by creating the widgets which the application will build upon. Every task in the application will consist of three widgets:</p>
<ul>
<li><code>gtk::Entry</code> for editing the text of a task</li>
<li><code>gtk::Button</code> for inserting a new task below this task</li>
<li><code>gtk::Button</code> for removing this task</li>
</ul>
<h2 id="widgetsrs"><a class="header" href="#widgetsrs">widgets.rs</a></h2>
<p>Take note that because our tasks are created dynamically at runtime, we'll want a way of tracking them, which we can achieve with a <code>SlotMap</code>. The <code>Task</code> struct is going to contain each of the widgets owned by this task, as well as the row where this task was stored.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{utils::spawn, Event, TaskEntity};
use async_channel::Sender;
use glib::{clone, SignalHandlerId};
use gtk::prelude::*;

pub struct Task {
    pub entry: gtk::Entry,
    pub insert: gtk::Button,
    pub remove: gtk::Button,

    // Tracks our position in the list
    pub row: i32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can construct our widgets.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Task {
    pub fn new(row: i32) -&gt; Self {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The text entry will horizontally expanded to consume as much space as possible</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entry = cascade! {
    gtk::Entry::new();
    ..set_hexpand(true);
    ..show();
};
<span class="boring">}
</span></code></pre></pre>
<p>Then we'll create our two buttons. It's good practice to use icons over text, because text requires translations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let insert = cascade! {
    gtk::Button::from_icon_name(Some(&quot;list-add-symbolic&quot;), gtk::IconSize::Button);
    ..show();
};

let remove = cascade! {
    gtk::Button::from_icon_name(Some(&quot;list-remove-symbolic&quot;), gtk::IconSize::Button);
    ..show();
};
<span class="boring">}
</span></code></pre></pre>
<p>We're not going to program these widgets just yet. Just return them as is to program later:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Task {
    pub fn new(row: i32) -&gt; Self {
        Self {
            insert: cascade! {
                gtk::Button::from_icon_name(Some(&quot;list-add-symbolic&quot;), gtk::IconSize::Button);
                ..show();
            },

            remove: cascade! {
                gtk::Button::from_icon_name(Some(&quot;list-remove-symbolic&quot;), gtk::IconSize::Button);
                ..show();
            },

            entry: cascade! {
                gtk::Entry::new();
                ..set_hexpand(true);
                ..show();
            },

            row,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You can find available system icons for your applications using <a href="https://www.flathub.org/apps/details/org.gnome.design.IconLibrary">IconLibray</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-app"><a class="header" href="#creating-the-app">Creating the App</a></h1>
<h2 id="apprs"><a class="header" href="#apprs">app.rs</a></h2>
<p>Now we can get to creating our <code>App</code> struct. This will contain all of the values that we will work with throughout the lifetime of our application.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{Event, BgEvent, TaskEntity};
use crate::widgets::Task;
use crate::utils::spawn;

use async_channel::Sender;
use glib::clone;
use glib::SourceId;
use gtk::prelude::*;
use slotmap::SlotMap;

pub struct App {
    pub container: gtk::Grid,
    pub tasks: SlotMap&lt;TaskEntity, Task&gt;,
    pub scheduled_write: Option&lt;SourceId&gt;,
    pub tx: Sender&lt;Event&gt;,
    pub btx: Sender&lt;BgEvent&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>All of our task widgets are going to be stored within the <code>container: gtk::Grid</code>. Each row of this grid will be associated with a task. The first column will contain the <code>gtk::Entry</code>, and the subsequent two columsn are the <code>gtk::Button</code>s. By using a grid, we can easily keep our widgets perfectly aligned in a grid.</p>
<p>The <code>tasks: SlotMap&lt;TaskEntity, Task&gt;</code> field will contain all the tasks we're currently maintaining. This will be important for looking up which row a task was assigned to.</p>
<p>When an entry has been modified, we're going to spawn a signal that waits until 5 seconds have passed since the last modification before sending an event to the background thread to save the contents of our task list, whose source ID is stored in <code>scheduled_write: Option&lt;SourceId&gt;</code>.</p>
<p>And without requiring much explanation, <code>tx</code> and <code>btx</code> are handles for sending UI and background events.</p>
<h3 id="setting-up-the-app"><a class="header" href="#setting-up-the-app">Setting up the App</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl App {
    pub fn new(
        app: &amp;gtk::Application,
        tx: Sender&lt;Event&gt;,
        btx: Sender&lt;BgEvent&gt;
    ) -&gt; Self {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The first step will be creating the <code>gtk::Grid</code> that we are going to assign our widgets to. Each column and row will have 4 units of padding around them, and the widget itself will also have some padding.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let container = cascade! {
    gtk::Grid::new();
    ..set_column_spacing(4);
    ..set_row_spacing(4);
    ..set_border_width(4);
    ..show();
};
<span class="boring">}
</span></code></pre></pre>
<p>Because it will be possible for there to be more tasks than a window can display at one time, this widget will be wrapped within a <code>gtk::ScrolledWindow</code>. By defining that the <code>hscrollbar-policy</code> is <code>Never</code>, this will prevent the scrolling window from horizontally scrolling, but will permit vertical scrolling as necessary.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let scrolled = gtk::ScrolledWindowBuilder::new()
    .hscrollbar_policy(gtk::PolicyType::Never)
    .build();

scrolled.add(&amp;container);
<span class="boring">}
</span></code></pre></pre>
<p>Now we get to setting up our window, which we can create from the <code>&amp;gtk::Application</code> we received. Note that we are connecting our sender along with the scroller to the delete event. When the window is being destroyed, we are going to detach the scroller from the window so that it does not get destroyed alongside it. The purpose of doing so is to keep our <code>gtk::Entry</code> task widgets alive long enough for us to salvage the text in them to save their contents to the disk before we exit the application. Our sender is going to pass a UI event notifying our event handler about the window having been closed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _window = cascade! {
    gtk::ApplicationWindow::new(app);
    ..set_title(&quot;Todo&quot;);
    ..add(&amp;scrolled);
    ..connect_delete_event(clone!(@strong tx, @strong scrolled =&gt; move |win, _| {
        // Detach to preserve widgets after destruction of window
        win.remove(&amp;scrolled);

        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::Closed).await;
        });
        gtk::Inhibit(false)
    }));
    ..show_all();
};

gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The last step is putting our app together, creating the first row, and returning the <code>App</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut app = Self {
    container,
    tasks: SlotMap::with_key(),
    scheduled_write: None,
    tx,
    btx,
};

app.insert_row(0);

app
<span class="boring">}
</span></code></pre></pre>
<p>Your file should now look like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::{Event, BgEvent, TaskEntity};
use crate::widgets::Task;
use crate::utils::spawn;

use async_channel::Sender;
use glib::clone;
use glib::SourceId;
use gtk::prelude::*;
use slotmap::SlotMap;

pub struct App {
    pub container: gtk::Grid,
    pub tasks: SlotMap&lt;TaskEntity, Task&gt;,
    pub scheduled_write: Option&lt;SourceId&gt;,
    pub tx: Sender&lt;Event&gt;,
    pub btx: Sender&lt;BgEvent&gt;,
}

impl App {
    pub fn new(app: &amp;gtk::Application, tx: Sender&lt;Event&gt;, btx: Sender&lt;BgEvent&gt;) -&gt; Self {
        let container = cascade! {
            gtk::Grid::new();
            ..set_column_spacing(4);
            ..set_row_spacing(4);
            ..set_border_width(4);
            ..show();
        };

        let scrolled = gtk::ScrolledWindowBuilder::new()
            .hscrollbar_policy(gtk::PolicyType::Never)
            .build();

        scrolled.add(&amp;container);

        let _window = cascade! {
            gtk::ApplicationWindow::new(app);
            ..set_title(&quot;Todo&quot;);
            ..set_default_size(400, 600);
            ..add(&amp;scrolled);
            ..connect_delete_event(clone!(@strong tx, @strong scrolled =&gt; move |win, _| {
                // Detach to preserve widgets after destruction of window
                win.remove(&amp;scrolled);

                let tx = tx.clone();
                spawn(async move {
                    let _ = tx.send(Event::Closed).await;
                });
                gtk::Inhibit(false)
            }));
            ..show_all();
        };

        gtk::Window::set_default_icon_name(&quot;icon-name-here&quot;);

        let mut app = Self {
            container,
            tasks: SlotMap::with_key(),
            scheduled_write: None,
            tx,
            btx,
        };

        app.insert_row(0);

        app
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inserting-and-removing-tasks"><a class="header" href="#inserting-and-removing-tasks">Inserting and Removing Tasks</a></h1>
<h2 id="apprs-1"><a class="header" href="#apprs-1">app.rs</a></h2>
<h3 id="inserting-a-row"><a class="header" href="#inserting-a-row">Inserting a Row</a></h3>
<p>Back to our <code>App</code> struct, we're going to work on the ability to insert a row by the row indice.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_row(&amp;mut self, row: i32) -&gt; TaskEntity {

}
<span class="boring">}
</span></code></pre></pre>
<p>When inserting a row, we will want to increment the row value of each task is below the row being added. We can achieve that by iterating our SlotMap of tasks by value, mutably. task that has a row that is greater or equal to the row being inserted will be incremented by 1.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increment the row value of each Task is below the new row
for task in self.tasks.values_mut() {
    if task.row &gt;= row {
        task.row += 1;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we instruct our <code>gtk::Grid</code> to insert this new row, pushing down all rows beneath it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.container.insert_row(row);
<span class="boring">}
</span></code></pre></pre>
<p>Next we'll create our task widgets, and assign them to the grid. The <code>.attach()</code> method takes the widget to assign, followed by the column, row, width, and height parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let task = Task::new(row);

self.container.attach(&amp;task.entry, 0, row, 1, 1);
self.container.attach(&amp;task.insert, 1, row, 1, 1);
self.container.attach(&amp;task.remove, 2, row, 1, 1);
<span class="boring">}
</span></code></pre></pre>
<p>We should also ensure that the newly-added <code>gtk::Entry</code> will grab the focus of our keyboard</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>task.entry.grab_focus();
<span class="boring">}
</span></code></pre></pre>
<p>Now we can assign this newly-created <code>Task</code> to our SlotMap. This will return a key, which we will use as identifiers to the signals we're now going to connect.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let entity = self.tasks.insert(task);
self.tasks[entity].connect(self.tx.clone(), entity);
return entity;
<span class="boring">}
</span></code></pre></pre>
<p>Your method should now look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn insert_row(&amp;mut self, row: i32) -&gt; TaskEntity {
    // Increment the row value of each Task is below the new row
    for task in self.tasks.values_mut() {
        if task.row &gt;= row {
            task.row += 1;
        }
    }

    self.container.insert_row(row);
    let task = Task::new(row);

    self.container.attach(&amp;task.entry, 0, row, 1, 1);
    self.container.attach(&amp;task.insert, 1, row, 1, 1);
    self.container.attach(&amp;task.remove, 2, row, 1, 1);

    task.entry.grab_focus();

    let entity = self.tasks.insert(task);
    self.tasks[entity].connect(self.tx.clone(), entity);
    return entity;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="widgetsrs-1"><a class="header" href="#widgetsrs-1">widgets.rs</a></h2>
<p>It is at this point where we are going to start connecting the signals to our task widgets. Add the following method to your <code>Task</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn connect(&amp;mut self, tx: Sender&lt;Event&gt;, entity: TaskEntity) {

}

<span class="boring">}
</span></code></pre></pre>
<p>First we will have the entry send <code>Event::Modified</code> whenever it has changed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.entry.connect_changed(clone!(@strong tx =&gt; move |_| {
    let tx = tx.clone();
    spawn(async move {
        let _ = tx.send(Event::Modified).await;
    });
}));
<span class="boring">}
</span></code></pre></pre>
<p>Then we will program insert button to send <code>Event::Insert(entity)</code> when it has been clicked. Although we will only send this signal if the entry for this task is empty. Note that we are taking the entry widget by weak reference. This will prevent a potential cyclic reference when two widgets happen to depend on each other in their signals. The <code>clone!</code> macro will automatically handle creating the weak reference, and upgrading that reference in our signal.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.insert
    .connect_clicked(clone!(@strong tx, @weak self.entry as entry =&gt; move |_| {
        if entry.get_text_length() == 0 {
            return;
        }

        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::Insert(entity)).await;
        });
    }));
<span class="boring">}
</span></code></pre></pre>
<p>Then the remove button:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.remove.connect_clicked(clone!(@strong tx =&gt; move |_| {
    let tx = tx.clone();
    spawn(async move {
        let _ = tx.send(Event::Remove(entity)).await;
    });
}));
<span class="boring">}
</span></code></pre></pre>
<p>And to respond to when the user presses the Enter key, which should be treated as equivalent to clicking the insert button:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    self.entry
        .connect_activate(clone!(@weak self.entry as entry =&gt; move |_| {
            if entry.get_text_length() == 0 {
                return;
            }

            let tx = tx.clone();
            spawn(async move {
                let _ = tx.send(Event::Insert(entity)).await;
            });
        }));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="apprs-2"><a class="header" href="#apprs-2">app.rs</a></h2>
<p>Moving back to our app module, we'll add another method for inserting a row. Because our application is going to insert new rows from received events via the <code>TaskEntity</code> that was received in the <code>Insert(TaskEntity)</code> event, we need to add the method that our application is going to call. After fetching the task from the SlotMap, we can use the conveniently-stored <code>row</code> value to determine where we're going to insert a new row.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insert(&amp;mut self, entity: TaskEntity) {
    let mut insert_at = 0;

    if let Some(task) = self.tasks.get(entity) {
        insert_at = task.row + 1;
    }

    self.insert_row(insert_at);
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we get to removing tasks. When we receive that <code>Remove(TaskEntity)</code> event, we're going to call <code>app.remove(entity)</code>. We'll ignore any requests to delete the last task from the list, since that would render our application unusable. If we're allowed to remove a task, we'll remove the task from the SlotMap, and call <code>grid.remove_row(&amp;widget)</code> on our <code>container</code> to remove all the widgets from that task's row from the container. The widgets will be automatically destroyed after returning from this function, because the last remaining strong references to them have been wiped out.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn remove(&amp;mut self, entity: TaskEntity) {
    if self.tasks.len() == 1 {
        return;
    }
    self.remove_(entity);
}

fn remove_(&amp;mut self, entity: TaskEntity) {
    if let Some(removed) = self.tasks.remove(entity) {
        self.container.remove_row(removed.row);

        // Decrement the row value of the tasks that were below the removed row
        for task in self.tasks.values_mut() {
            if task.row &gt; removed.row {
                task.row -= 1;
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And of course, similar to having to increment the row values on insert, we'll do the reverse on removal of a widget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signaling-when-to-save"><a class="header" href="#signaling-when-to-save">Signaling when to Save</a></h1>
<h2 id="apprs-3"><a class="header" href="#apprs-3">app.rs</a></h2>
<p>There are two scenarios where we will save our tasks to a file. When the application has been closed, and every 5 seconds after the last modification. To start, lets add a signal that waits 5 seconds before sending the <code>SyncToDisk</code> event:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn modified(&amp;mut self) {
    if let Some(id) = self.scheduled_write.take() {
        glib::source_remove(id);
    }

    let tx = self.tx.clone();
    self.scheduled_write = Some(glib::timeout_add_local(5000, move || {
        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::SyncToDisk).await;
        });

        glib::Continue(false)
    }));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>glib::timeout_add_local(5000, ...)</code> will schedule the provided closure to execute on local context after 5 seconds. This function returns an ID which we're storing in the <code>scheduled_write</code> property of our <code>App</code>. If we receive the <code>Modified</code> event again before the 5 seconds have passed, the previous signal will be removed and a new one registered in its place. That'll ensure that it doesn't trigger until after 5 seconds of idle keyboard time has passed.</p>
<p>Next will be programming the <code>SyncToDisk</code> event. We're simply going to collect the text from each non-empty task widget in our slotmap, and combine it into a single string to pass to the background for saving. The <code>fomat</code> formatter from the <code>fomat_macros</code> crate provides a very intuitive means to achieve this.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn sync_to_disk(&amp;mut self) {
    self.scheduled_write = None;

    let contents = fomat_macros::fomat!(
        for node in self.tasks.values() {
            if node.entry.get_text_length() != 0 {
                (node.entry.get_text()) &quot;\n&quot;
            }
        }
    );

    let _ = self.btx.send(BgEvent::Save(&quot;Task&quot;.into(), contents)).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we can handle that <code>Closed</code> event that was sent when the <code>ApplicationWindow</code> was destroyed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn closed(&amp;mut self) {
    self.sync_to_disk().await;
    let _ = self.btx.send(BgEvent::Quit).await;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loading-tasks-from-a-file"><a class="header" href="#loading-tasks-from-a-file">Loading tasks from a file</a></h1>
<h2 id="apprs-4"><a class="header" href="#apprs-4">app.rs</a></h2>
<p>If in the future, we implement the ability to open a different list, we'll need a way of clearing the UI of the previous list. This simply involves popping out every task in the map and removing them one by one.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn clear(&amp;mut self) {
    while let Some(entity) = self.tasks.keys().next() {
        self.remove_(entity);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When we receive the contents of a list to load into our UI, we're going to split the string by newlines and create a row for each one, then insert that text into their entries.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn load(&amp;mut self, data: String) {
    self.clear();

    for (row, line) in data.lines().enumerate() {
        let entity = self.insert_row(row as i32);
        self.tasks[entity].set_text(line);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="widgetsrs-2"><a class="header" href="#widgetsrs-2">widgets.rs</a></h2>
<p>Because we are automatically filling out the contents of the <code>Task::entry</code> for each task that we load from a file, and we are listening to any changes made to these entries when we send the <code>Modified</code> event, we need to block that signal when we are setting the text in the entry. Add the following new property to <code>Task</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>entry_signal: Option&lt;SignalHandlerId&gt;,
<span class="boring">}
</span></code></pre></pre>
<p>Which we'll need to assign to <code>None</code> in our <code>Task::new()</code> method. Then change the <code>connect_changed</code> signal for the entry to the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let signal = self.entry.connect_changed(clone!(@strong tx =&gt; move |_| {
    let tx = tx.clone();
    spawn(async move {
        let _ = tx.send(Event::Modified).await;
    });
}));

self.entry_signal = Some(signal);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can safely add a method for setting the text on this entry, first by blocking that signal, setting the text, and unblocking it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn set_text(&amp;mut self, text: &amp;str) {
    let signal = self.entry_signal.as_ref().unwrap();
    self.entry.block_signal(signal);
    self.entry.set_text(text);
    self.entry.unblock_signal(signal);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marking--removing-done-tasks-with-checkbuttons"><a class="header" href="#marking--removing-done-tasks-with-checkbuttons">Marking &amp; Removing Done Tasks with CheckButtons</a></h1>
<p>We are going to remove the remove buttons from each task and replace them with check buttons. To remove tasks from the list, we will replace the application's title bar with a <code>gtk::HeaderBar</code>, and place a delete button here that will show when any tasks have been checked.</p>
<h2 id="mainrs-3"><a class="header" href="#mainrs-3">main.rs</a></h2>
<p>We're adding two new events to our <code>Event</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Delete,
Toggled(bool),
<span class="boring">}
</span></code></pre></pre>
<p>Handling it in our event handler:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Event::Toggled(active) =&gt; app.toggled(active),
Event::Delete =&gt; app.delete(),
<span class="boring">}
</span></code></pre></pre>
<h2 id="widgetsrs-3"><a class="header" href="#widgetsrs-3">widgets.rs</a></h2>
<p>We can track if tasks are completed with check marks, and remove them together in a batch. Add a new field to our <code>Task</code> struct to add a <code>gtk::CheckButton</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>check: gtk::CheckButton
<span class="boring">}
</span></code></pre></pre>
<p>Since we're going to use these check marks for removal operations, we can remove the <code>remove</code> button as well.</p>
<p>Then construct the widget and return it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Self {
    check: cascade! {
        gtk::CheckButton::new();
        ..show();
    },

    insert: cascade! {
        gtk::Button::from_icon_name(Some(&quot;list-add-symbolic&quot;), gtk::IconSize::Button);
        ..show();
    },

    entry: cascade! {
        gtk::Entry::new();
        ..set_hexpand(true);
        ..show();
    },

    entry_signal: None,
    row,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we can add an event for when the button is toggled:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.check.connect_toggled(clone!(@strong tx =&gt; move |check| {
    let tx = tx.clone();
    let check = check.clone();
    spawn(async move {
        let _ = tx.send(Event::Toggled(check.get_active())).await;
    })
}));
<span class="boring">}
</span></code></pre></pre>
<h2 id="apprs-5"><a class="header" href="#apprs-5">app.rs</a></h2>
<h3 id="task-widgets"><a class="header" href="#task-widgets">Task Widgets</a></h3>
<p>Then modify the attachments of these widgets in the app:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.container.attach(&amp;task.check, 0, row, 1, 1);
self.container.attach(&amp;task.entry, 1, row, 1, 1);
self.container.attach(&amp;task.insert, 2, row, 1, 1);
<span class="boring">}
</span></code></pre></pre>
<h3 id="delete-button"><a class="header" href="#delete-button">Delete Button</a></h3>
<p>Now we're going to create the delete button, with both an icon and a label. By default, a button is only permitted to have either an image or a label, but we can force it to show both by setting the <code>always_show_image</code> property. We also don't want this button to be shown when the window is shown, so we need to call <code>.set_no_show_all(true)</code>. Since this button performs a destructive action, we should style it as such with <code>.get_style_context().add_class(&amp;gtk::STYLE_CLASS_DESTRUCTIVE_ACTION)</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let delete_button = cascade! {
    gtk::Button::from_icon_name(Some(&quot;edit-delete-symbolic&quot;), gtk::IconSize::Button);
    ..set_label(&quot;Delete&quot;);
    // Show the icon alongside the label
    ..set_always_show_image(true);
    // Don't show this when the window calls `.show_all()`
    ..set_no_show_all(true);
    // Give this a destructive styling to signal that the action is destructive
    ..get_style_context().add_class(&amp;gtk::STYLE_CLASS_DESTRUCTIVE_ACTION);
    // Send the `Delete` event on click
    ..connect_clicked(clone!(@strong tx =&gt; move |_| {
        let tx = tx.clone();
        spawn(async move {
            let _ = tx.send(Event::Delete).await;
        });
    }));
};
<span class="boring">}
</span></code></pre></pre>
<p>This button widget will be attached to the title bar via the <code>gtk::HeaderBar</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let headerbar = cascade! {
    gtk::HeaderBar::new();
    ..pack_end(&amp;delete_button);
    ..set_title(Some(&quot;ToDo&quot;));
    ..set_show_close_button(true);
};
<span class="boring">}
</span></code></pre></pre>
<p>Then modify our <code>ApplicationWindow</code> to change <code>.set_title()</code> for the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>..set_titlebar(Some(&amp;headerbar));
<span class="boring">}
</span></code></pre></pre>
<p>And update our <code>App</code> struct to add the delete button.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>delete_button: gtk::Button
<span class="boring">}
</span></code></pre></pre>
<h3 id="handling-toggle-events"><a class="header" href="#handling-toggle-events">Handling Toggle Events</a></h3>
<p>We will show the delete button only when there is at least one active task checked. We can achieve this by adding another property to the <code>App</code> struct to track how many tasks are actively checked.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checks_active: u32
<span class="boring">}
</span></code></pre></pre>
<p>By default, assigning it in our constructor to <code>0</code> of course</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>checks_active: 0
<span class="boring">}
</span></code></pre></pre>
<p>Then we'll add the toggled method for handling the toggle events. If the event is toggled active, we increment the number. We do the reverse when it is unchecked. If the number is non-zero, we set the button as visible.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn toggled(&amp;mut self, active: bool) {
    if active {
        self.checks_active += 1;
    } else {
        self.checks_active -= 1;
    }

    self.delete_button.set_visible(self.checks_active != 0);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="handling-delete-events"><a class="header" href="#handling-delete-events">Handling Delete Events</a></h3>
<p>When we've been requested to delete tasks that were marked as active, we'll iterate through our tasks and collect the entity IDs of each task that is active. We need to collect these into a vector on the side so that we're not modifying our task list as we're iterating across it. Once we have a list of tasks to remove, we'll call our remove method with each entity ID. Finally, we'll set the <code>checks_active</code> back to <code>0</code> and hide the button.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn delete(&amp;mut self) {
    let remove_list = self.tasks.iter()
        .filter(|(_, task)| task.check.get_active())
        .map(|(id, _)| id)
        .collect::&lt;Vec&lt;TaskEntity&gt;&gt;();

    for id in remove_list {
        self.remove(id);
    }

    self.checks_active = 0;
    self.delete_button.set_visible(false);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-multiple-todo-lists"><a class="header" href="#managing-multiple-todo-lists">Managing Multiple ToDo Lists</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
